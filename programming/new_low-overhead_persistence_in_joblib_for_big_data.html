<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Gaël Varoquaux, computer / data / health science">

        <link rel="alternate"  href="http://gael-varoquaux.info/feeds/all.atom.xml" type="application/atom+xml" title="Gaël Varoquaux Full Atom Feed"/>

        <title>Better Python compressed persistence in joblib -- Gaël Varoquaux: computer / data / health science</title>


    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.3.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="http://gael-varoquaux.info/theme/css/pure.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
</head>

<body>
<div class="pure-g-r" id="layout">
    <div class="sidebar sidebar-article pure-u">
        <header class="header-article">
            <hgroup>
                <a href="http://gael-varoquaux.info">
		    <img class="avatar" alt="Gaël Varoquaux" 
                     src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/110px-Python-logo-notext.svg.png">
                </a>
                <a href="http://gael-varoquaux.info" class="article-info">
		    <h2 class="article-info">Alexandre Abadie & Gaël Varoquaux</h2>
		</a>
                <p>Fri 20 May 2016</p>
                <a href="/">&larr;Home</a>
            </hgroup>
        </header>
    </div>
    <div class="pure-u">
        <div class="content">
            <section class="post">
                <header class="post-header">
                    <h1>Better Python compressed persistence in joblib</h1>
                        <p class="post-meta">
                            under                                 <a class="post-category" href="http://gael-varoquaux.info/tag/joblib.html">joblib</a>
                                <a class="post-category" href="http://gael-varoquaux.info/tag/persistence.html">persistence</a>
                                <a class="post-category" href="http://gael-varoquaux.info/tag/big-data.html">big data</a>
		    <span class="readtime">
			&nbsp Read time: 9 min.
		    </span>
<!--<script src="https://apis.google.com/js/platform.js" async defer></script>-->
<span class="social_links">
<a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="GaelVaroquaux">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js" async defer></script>
<!-- Place this tag where you want the +1 button to render. -->
<span class="g-plusone" data-size="medium"></span>
</span>                        </p>
                </header>
            </section>
            <div class="section" id="problem-setting-persistence-for-big-data">
<h2>Problem setting: persistence for big data</h2>
<p><a class="reference external" href="https://pythonhosted.org/joblib/">Joblib</a> is a powerful Python package
for management of computation: parallel computing, caching, and
primitives for out-of-core computing. It is handy when working on so
called <strong>big data</strong>, that can consume more than the available RAM (several GB
nowadays). In such situations, objects in the working space must be
persisted to disk, for out-of-core computing, distribution of jobs, or
caching.</p>
<p>An efficient strategy to write code dealing with big data is to rely on
<strong>numpy arrays to hold large chunks of structured data</strong>.
The code then handles objects or arbitrary containers (list, dict) with
numpy arrays. For data management, joblib provides transparent disk
persistence that is very efficient with such objects. The internal
mechanism relies on specializing <a class="reference external" href="https://docs.python.org/3/library/pickle.html">pickle</a> to handle better numpy
arrays.</p>
<p><a class="reference external" href="https://github.com/joblib/joblib/pull/260">Recent improvements</a>
reduce vastly the memory overhead of data persistence.</p>
<div class="section" id="limitations-of-the-old-implementation">
<h3>Limitations of the old implementation</h3>
<p>❶ Dumping/loading persisted data <strong>with compression</strong> was a memory hog,
because of internal copies of data, limiting the maximum size
of usable data with compressed persistence:</p>
<img alt="" class="large" src="http://gael-varoquaux.info/programming/attachments/old_pickle_mem_profile.png" />
<p>We see the increased memory usage during the calls to <tt class="docutils literal">dump</tt> and
<tt class="docutils literal">load</tt> functions, profiled using the <a class="reference external" href="https://pypi.python.org/pypi/memory_profiler">memory_profiler package</a> with this <a class="reference external" href="https://gist.github.com/aabadie/7cba3385406d1cec7d3dd4407ba3f164">gist</a></p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>❷ Another drawback was that large numpy arrays (&gt;10MB) contained in an
arbitrary Python object were dumped in separate <tt class="docutils literal">.npy</tt> file, increasing
the load on the file system <a class="footnote-reference" href="#id4" id="id1">[1]</a>:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">joblib</span> <span class="c1"># joblib version: 0.9.4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">5000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">))]</span>

<span class="c1"># 3 files are generated:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;/tmp/test.pkl&#39;</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;/tmp/test.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;/tmp/test.pkl_01.npy.z&#39;</span><span class="p">,</span> <span class="s1">&#39;/tmp/test.pkl_02.npy.z&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/test.pkl&#39;</span><span class="p">)</span>
<span class="p">[</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]],</span>
 <span class="n">array</span><span class="p">([[</span> <span class="mf">0.47006195</span><span class="p">,</span>  <span class="mf">0.5436392</span> <span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">0.1218267</span> <span class="p">,</span>  <span class="mf">0.48592789</span><span class="p">]])]</span>
</pre></div>
<!-- XXX: announce content of post earlier

Let's now discover the new features and improvements that comes with
version 0.10.0. After that, we'll compare speed and memory consumption with
other libraries and discuss the results. Then we'll give some details about the
new internal implementation. -->
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="what-s-new-compression-low-memory">
<h2>What’s new: compression, low memory…</h2>
<p>❶ <strong>Memory usage is now stable</strong>:</p>
<img alt="" src="http://gael-varoquaux.info/programming/attachments/new_pickle_mem_profile.png" />
<p>❷ <strong>All numpy arrays are persisted in a single file</strong>:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">joblib</span> <span class="c1"># joblib version: 0.10.0 (dev)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">5000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">))]</span>

<span class="c1"># only 1 file is generated:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;/tmp/test.pkl&#39;</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;/tmp/test.pkl&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/test.pkl&#39;</span><span class="p">)</span>
<span class="p">[</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]],</span>
 <span class="n">array</span><span class="p">([[</span> <span class="mf">0.47006195</span><span class="p">,</span>  <span class="mf">0.5436392</span> <span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">0.1218267</span> <span class="p">,</span>  <span class="mf">0.48592789</span><span class="p">]])]</span>
</pre></div>
<p>❸ <strong>Persistence in a file handle</strong> (ongoing work in a <a class="reference external" href="https://github.com/joblib/joblib/pull/351">pull request</a>)</p>
<p>❹ <strong>More compression formats are available</strong></p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="topic">
<p class="topic-title">Backward compatibility</p>
<p>Existing joblib users can be reassured: the new version is <strong>still
compatible with pickles generated by older versions</strong> (&gt;= 0.8.4). You
are encouraged to update (rebuild?) your cache if you want to take
advantage of this new version.</p>
</div>
</div>
<div class="section" id="benchmarks-speed-and-memory-consumption">
<h2>Benchmarks: speed and memory consumption</h2>
<p>Joblib strives to have <strong>minimum dependencies</strong> (only numpy) and to
<strong>be agnostic to the input data</strong>. Hence the goals are to deal with any
kind of data while trying to <strong>be as efficient as possible with numpy arrays</strong>.</p>
<p>To illustrate the benefits and cost of the new persistence implementation, let’s
now compare a real life use case
(<a class="reference external" href="http://scikit-learn.org/stable/modules/generated/sklearn.datasets.fetch_lfw_people.html">LFW dataset from scikit-learn</a>)
with different libraries:</p>
<ul class="simple">
<li>Joblib, with 2 different versions,
0.9.4 and master (dev),</li>
<li>Pickle</li>
<li>Numpy</li>
</ul>
<img alt="" class="large" src="http://gael-varoquaux.info/programming/attachments/persistence_lfw_bench.png" />
<p>The four first lines use non compressed persistence strategies, the last
four use persistence with zlib/gzip <a class="footnote-reference" href="#id5" id="id2">[2]</a> strategies. Code to reproduce the
benchmarks is available on this <a class="reference external" href="https://gist.github.com/aabadie/2ba94d28d68f19f87eb8916a2238a97c">gist</a>.</p>
<p>⚫ <strong>Speed</strong>: the results between joblib 0.9.4 and 0.10.0 (dev) are
similar whereas <strong>numpy and pickle are clearly slower than joblib</strong> in both
compressed and non compressed cases.</p>
<p>⚫ <strong>Memory consumption</strong>: Without compression, old and
new joblib versions are the same; with compression, the new joblib version is
much better than the old one.
<strong>Joblib clearly outperforms pickle and numpy in terms of
memory consumption</strong>. This can be explained by the fact that numpy relies on
pickle if the object is not a pure numpy array (a list or a dict with arrays for
example), so in this case it inherits the memory drawbacks from pickle. When
persisting pure numpy arrays (not tested here), numpy uses its internal save/load
functions which are efficient in terms of speed and memory consumption.</p>
<p>⚫ <strong>Disk used</strong>: results are as expected: non compressed files have
the same size as the in-memory data; compressed files are smaller.</p>
<div class="topic">
<p class="topic-title">Caveat Emptor: performance is data-dependent</p>
<p>Different data compress more or less easily. Speed and disk used will
vary depending on the data. Key considerations are:</p>
<ul class="simple">
<li><strong>Fraction of data in arrays</strong>: joblib is efficient if much of the
data is contained in numpy arrays. The worst case scenario is
something like a large dictionary of random numbers as keys and
values.</li>
<li><strong>Entropy of the data</strong>: an array fully of zeros will compress well
and fast. A fully random array will compress slowly, and use a lot
of disk. Real data is often somewhere in the middle.</li>
</ul>
</div>
</div>
<div class="section" id="extra-improvements-in-compressed-persistence">
<h2>Extra improvements in compressed persistence</h2>
<div class="section" id="new-compression-formats">
<h3>New compression formats</h3>
<p>Joblib can use new compression formats based on Python standard library modules:
<strong>zlib, gzip, bz2, lzma and xz</strong> (the last 2 are available for Python
greater than 3.3). <strong>The compressor is
selected automatically when the file name has an explicit extension</strong>:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;/tmp/test.pkl.z&#39;</span><span class="p">)</span>   <span class="c1"># zlib</span>
<span class="p">[</span><span class="s1">&#39;/tmp/test.pkl.z&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;/tmp/test.pkl.gz&#39;</span><span class="p">)</span>  <span class="c1"># gzip</span>
<span class="p">[</span><span class="s1">&#39;/tmp/test.pkl.gz&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;/tmp/test.pkl.bz2&#39;</span><span class="p">)</span>  <span class="c1"># bz2</span>
<span class="p">[</span><span class="s1">&#39;/tmp/test.pkl.bz2&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;/tmp/test.pkl.lzma&#39;</span><span class="p">)</span>  <span class="c1"># lzma</span>
<span class="p">[</span><span class="s1">&#39;/tmp/test.pkl.lzma&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;/tmp/test.pkl.xz&#39;</span><span class="p">)</span>  <span class="c1"># xz</span>
<span class="p">[</span><span class="s1">&#39;/tmp/test.pkl.xz&#39;</span><span class="p">]</span>
</pre></div>
<p>One can tune the compression level, setting the compressor explicitly:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;/tmp/test.pkl.compressed&#39;</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;zlib&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">[</span><span class="s1">&#39;/tmp/test.pkl.compressed&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;/tmp/test.compressed&#39;</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;lzma&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">[</span><span class="s1">&#39;/tmp/test.pkl.compressed&#39;</span><span class="p">]</span>
</pre></div>
<p>On loading, joblib uses the magic number of the file to determine the
right decompression method. This makes loading compressed pickle transparent:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/test.compressed&#39;</span><span class="p">)</span>
<span class="p">[</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]],</span>
 <span class="n">array</span><span class="p">([[</span> <span class="mf">0.47006195</span><span class="p">,</span>  <span class="mf">0.5436392</span> <span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">0.1218267</span> <span class="p">,</span>  <span class="mf">0.48592789</span><span class="p">]])]</span>
</pre></div>
<p>Importantly, the generated compressed files use a <strong>standard
compression file format</strong>: for instance, regular command line tools (zip/unzip,
gzip/gunzip, bzip2, lzma, xz) can be used to compress/uncompress a pickled file
generated with joblib. Joblib will be able to load cache compressed with those
tools.</p>
<div class="topic">
<p class="topic-title">Toward more and faster compression</p>
<p>Specific compression strategies have been developped for fast
compression, sometimes even faster than disk reads such as <a class="reference external" href="http://google.github.io/snappy/">snappy</a> , <a class="reference external" href="http://www.blosc.org/">blosc</a>, LZO or LZ4. With a file-like interface, they should be
readily usable with joblib.</p>
<p>In the benchmarks above, loading and dumping with compression is
slower than without (though only by a factor of 3 for loading). These
were done on a computer with an SSD, hence with very fast I/O. In a
situation with slower I/O, as <strong>on a network drive, compression could
save time</strong>. With faster compressors, compression will save time on most
hardware.</p>
</div>
</div>
<div class="section" id="compressed-persistence-into-a-file-handle">
<h3>Compressed persistence into a file handle</h3>
<p>Now that everything is stored in a
single file using standard compression formats, joblib can
persist in an <a class="reference external" href="https://github.com/joblib/joblib/pull/351">open file handle</a>:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/tmp/test.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="o">&gt;&gt;&gt;</span>    <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;/tmp/test.pkl&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/tmp/test.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="o">&gt;&gt;&gt;</span>    <span class="nb">print</span><span class="p">(</span><span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="p">[</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]],</span>
 <span class="n">array</span><span class="p">([[</span> <span class="mf">0.47006195</span><span class="p">,</span>  <span class="mf">0.5436392</span> <span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">0.1218267</span> <span class="p">,</span>  <span class="mf">0.48592789</span><span class="p">]])]</span>
</pre></div>
<p>This also works with compression file object available in the standard library,
like <tt class="docutils literal">gzip.GzipFile</tt>, <tt class="docutils literal">bz2.Bz2File</tt> or <tt class="docutils literal">lzma.LzmaFile</tt>:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">gzip</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="s1">&#39;/tmp/test.pkl.gz&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="o">&gt;&gt;&gt;</span>    <span class="n">joblib</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;/tmp/test.pkl.gz&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="s1">&#39;/tmp/test.pkl.gz&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="o">&gt;&gt;&gt;</span>    <span class="nb">print</span><span class="p">(</span><span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="p">[</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]],</span>
 <span class="n">array</span><span class="p">([[</span> <span class="mf">0.47006195</span><span class="p">,</span>  <span class="mf">0.5436392</span> <span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">0.1218267</span> <span class="p">,</span>  <span class="mf">0.48592789</span><span class="p">]])]</span>
</pre></div>
<p>Be sure that you use a decompressor matching the internal compression when
loading with the above method. If
unsure, simply use <tt class="docutils literal">open</tt>, joblib will <strong>select the right decompressor</strong>:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/tmp/test.pkl.gz&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="nb">print</span><span class="p">(</span><span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="p">[</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]],</span>
 <span class="n">array</span><span class="p">([[</span> <span class="mf">0.47006195</span><span class="p">,</span>  <span class="mf">0.5436392</span> <span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mf">0.1218267</span> <span class="p">,</span>  <span class="mf">0.48592789</span><span class="p">]])]</span>
</pre></div>
<div class="topic">
<p class="topic-title">Towards dumping to elaborate stores</p>
<p>Working with file handles opens the door to <strong>storing cache data in database blob or cloud
storage such as Amazon S3, Amazon Glacier and Google Cloud Storage</strong>
(for instance via the Python package <a class="reference external" href="https://github.com/boto/boto">boto</a>).</p>
</div>
</div>
</div>
<div class="section" id="implementation">
<h2>Implementation</h2>
<p><strong>A Pickle Subclass</strong>: joblib relies on subclassing the Python Pickler/Unpickler
<a class="footnote-reference" href="#id6" id="id3">[3]</a>. These are state machines that walk the graph of nested objects (a
dict may contain a list, that may contain…), creating a string
representation of each object encountered. The new implementation
proceeds as follows:</p>
<ul class="simple">
<li><strong>Pickling an arbitrary object</strong>: when an <tt class="docutils literal">np.ndarray</tt> object is reached,
instead of using the default pickling functions (__reduce__()), the joblib
Pickler replaces in pickle stream the ndarray with a wrapper object containing
all important array metadata (shape, dtype, flags). Then it writes the array
content in the pickle file. Note that this step breaks the pickle
compatibility. One benefit is that it enables using fast code for
copyless handling of the numpy array. For compression, we pass chunks
of the data to a compressor object (using the buffer protocol to avoid
copies).</li>
<li><strong>Unpickling from a file</strong>: when pickle reaches the array wrapper, as the
object is in the pickle stream, the file handle is at the
beginning of the array content. So at this point the Unpickler simply
constructs an array based on the metadata contained in the wrapper and then
fills the array buffer directly from the file. The object returned is the
reconstructed array, the array wrapper being dropped. A benefit is that
if the data is stored not compressed, <strong>the array can be directly memory
mapped from the storage</strong> (the mmap_mode option of <a class="reference external" href="https://pythonhosted.org/joblib/generated/joblib.load.html">joblib.load</a>).</li>
</ul>
<p>This technique allows joblib to pickle all objects in a single file but also to
have memory-efficient dump and load.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>A fast compression stream</strong>: as the pickling refactoring opens the door
to file objects usage, joblib is now able to persist data in any kind of file
object: <tt class="docutils literal">open</tt>, <tt class="docutils literal">gzip.GzipFile</tt>, <tt class="docutils literal">bz2.Bz2file</tt> and <tt class="docutils literal">lzma.LzmaFile</tt>. For
performance reason and usability, the new joblib version uses its own file
object <tt class="docutils literal">BinaryZlibFile</tt> for zlib compression. Compared to
<tt class="docutils literal">GzipFile</tt>, it disables crc computation, which bring a performance gain of 15%.</p>
<div class="topic">
<p class="topic-title">Speed penalties of on-the-fly writes</p>
<p>There’s also a small speed difference with dict/list objects between new/old
joblib when using compression.
The old version pickles the data inside a <tt class="docutils literal">io.BytesIO</tt> buffer and then
compress it in a row whereas the new version write “on the fly” compressed
chunk of pickled data to the file.
Because of this internal buffer the old implementation is not memory safe as it
indeed copy the data in memory before compressing. The small speed difference
was judged acceptable compared to this memory duplication.</p>
</div>
</div>
<div class="section" id="conclusion-and-future-work">
<h2>Conclusion and future work</h2>
<p>Memory copies were a limitation when caching on disk very large
numpy arrays, e.g arrays with a size close to the available RAM on the computer.
The problem was solved via intensive buffering and a lot of hacking on top of
pickle and numpy. Unfortunately, our strategy has poor performance with
big dictionaries or list compared to a <tt class="docutils literal">cPickle</tt>, hence try to use
numpy arrays in your internal data structures (note that something like
scipy sparse matrices works well, as it builds on arrays).</p>
<p>For the future, maybe numpy’s pickle methods could be improved and make a
better use of <a class="reference external" href="https://www.python.org/dev/peps/pep-3154/#bit-opcodes-for-large-objects">64-bit opcodes for large objects</a>
that were introduced in Python recently.</p>
<p>Pickling using file handles is a first step toward pickling in
sockets, enabling broadcasting of data between computing units
on a network. This will be priceless with <a class="reference external" href="https://github.com/joblib/joblib/pull/325">joblib’s new distributed backends</a>.</p>
<p>Other improvements will come from better compressor, making everything
faster.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The pull request was implemented by <a class="reference external" href="https://github.com/aabadie">&#64;aabadie</a>. He thanks <a class="reference external" href="https://github.com/lesteve">&#64;lesteve</a>, <a class="reference external" href="https://github.com/ogrisel">&#64;ogrisel</a>
and <a class="reference external" href="https://github.com/GaelVaroquaux">&#64;GaelVaroquaux</a> for the valuable
help, reviews and support.</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>The load created by multiple files on the filesystem is
particularly detrimental for network filesystems, as it triggers
multiple requests and isn’t cache friendly.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>gzip is based on zlib with additional crc checks and a default
compression level of 3.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>A drawback of subclassing the Python Pickler/Unpickler is that it
is done for the pure-Python version, and not the “cPickle” version.
The latter is much faster when dealing with a large number of Python
objects. Once again, joblib is efficient when most of the data is
represented as numpy arrays or subclasses.</td></tr>
</tbody>
</table>
</div>

            <div class="hr" style="margin-bottom: -.5em;"></div>
<!--<script src="https://apis.google.com/js/platform.js" async defer></script>-->
<span class="social_links">
<a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="GaelVaroquaux">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js" async defer></script>
<!-- Place this tag where you want the +1 button to render. -->
<span class="g-plusone" data-size="medium"></span>
</span>            <a href="#" class="go-top">Go Top</a>
<footer class="footer">
    <p>&copy; Gaël Varoquaux &ndash;
        Built with <a href="https://github.com/PurePelicanTheme/pure">Pure Theme</a>
        for <a href="http://blog.getpelican.com/">Pelican</a>
    </p>
</footer>        </div>
    </div>
</div>
    <script
src="//cdnjs.cloudflare.com/ajax/libs/fitvids/1.0.1/jquery.fitvids.min.js"></script>
    <script>
        $(document).ready(function(){
            $(".content").fitVids();
        });
    </script>
    <script>
        var $top = $('.go-top');

        // Show or hide the sticky footer button
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                $top.fadeIn(200);
            } else {
                $top.fadeOut(200);
            }
        });

        // Animate the scroll to top
        $top.click(function(event) {
            event.preventDefault();
            $('html, body').animate({scrollTop: 0}, 300);
        })

        // Makes sure that the href="#" attached to the <a> elements
        // don't scroll you back up the page.
        $('body').on('click', 'a[href="#"]', function(event) {
            event.preventDefault();
        });
    </script>
    <script  language="JavaScript" type="text/javascript">
    /* From http://evirtus.net/pub/eflickrstream.asp */
    /* Global variables */
    var bolOnLoadRun=false;
    var bolFlickrRun=false;
    var objFlickrOutput=null;
    
    /* OnLoad events */
    window.onload = function() {
    bolOnLoadRun=true;
    if (! /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
	eFlickrStream();
    };
    }
    
    /*
    eFlickrStream - Lovely, lovely photos! :-)
    - 02.08.2007 @ 14:33: Initial version
    */
    function eFlickrStream() {
    if (!bolFlickrRun ) { return false; } else { bolFlickrRun=false; }
    if ((!document.createElement) && (!document.getElementById) && (!document.getElementsByTagName) ) { return false; }// Test for required browser capabilities
    
    /*   *** Options/start ***   */
    var strTarget='flickrstream';// Target container for the flickr badge (must allready exist in the document)
    /*   *** Options/end ***     */
    
    if (!document.getElementById(strTarget)){return false;}// Exsist if target doesn't exsist
    
    var objTarget=document.getElementById(strTarget);
    objTarget.appendChild(objFlickrOutput);// Append output
    
    objFlickrOutput=null;// We're done, delete stored variable value
    objFlickr=null;
    }
    
    /*
    jsonFlickrFeed - Triggered when the Flickr json "feed" is loaded, generates Flickr photos output list item (Deefer "trigger method" from Patrick Quinn-Graham's DOM Flickr Badge)
    - 02.08.2007 @ 14:33: Initial version
    - 23.11.2007 @ 08:24: Updated to use eSetAttr(), enables the flickr link in IE
    - 29.11.2007 @ 05:52: Some changes for easier configuration (of both options and text-strings)
    */
    function jsonFlickrFeed(objFlickr) {
    if ((!document.createElement) && (!document.getElementById) && (!document.getElementsByTagName) ) { return false; }// Test for required browser capabilities
    
    /*   *** Options/start ***   */
    var intMaxImages=10;// Maximum number of images to show (1-20)
    var bolThumbSquare=true;// Load the square thumbnails
    var intThumbWidth=75;// Thumbnail width (omitted if set to "0")
    var strLightbox='flickrstream';// Lightbox "group name" (define to mark the thumbnails for lightbox usage, adds rel="lightbox[value]" to image links)
    var strImgAlt='[title]';// Alternative title for images ("[title]" will be replaced by image title)
    var strImgLinkTitle='View a larger version of \"[title]\"';// Link title for the image link
    /*   *** Options/end ***     */
    
    var objElm,objTxt,objImg,objLnk,objTmp,strTmp;
    var intPhotos=objFlickr.items.length;
    var objOut=document.createElement('ul');
    objOut.setAttribute('class','flickrlist');
    
    for (var iCntA=0; ( (iCntA<intPhotos) && (iCntA<intMaxImages)); iCntA++) {
    
	objElm=document.createElement('li');// Create item container element (<li>)
    
	objLnk=document.createElement('a');// Create link (to the large(r) photo)
	objLnk.setAttribute('href',objFlickr.items[iCntA].link);
	objLnk.setAttribute('title',strImgLinkTitle.replace('[title]',objFlickr.items[iCntA].title));
	if (strLightbox!=''){objLnk.setAttribute('rel','lightbox['+strLightbox+']');}// Add relation value for lightbox usage
    
	strTmp=objFlickr.items[iCntA].media.m;// Retreive thumbnail URI
	if (bolThumbSquare){strTmp=strTmp.replace('_m.jpg','_s.jpg');}// Swap default thumbnail for square...
    
	objImg=document.createElement('img');// Main thumbnail
	eSetAttr(objImg,'class','photo');
	objImg.setAttribute('src',strTmp);
	objImg.setAttribute('alt',strImgAlt.replace('[title]',objFlickr.items[iCntA].title));
	if (intThumbWidth!=0){objImg.setAttribute('width',intThumbWidth);}
    
	objLnk.appendChild(objImg);// Append thumbnail to link
	objElm.appendChild(objLnk);// Append link to container (li)

	objOut.appendChild(objElm);// Append container to output object
	}
    
    objFlickrOutput=objOut;// Store output for later use...
    
    if (bolOnLoadRun) {
	eFlickrStream();
	}
    else {
	bolFlickrRun=true;
	}
    }
    
    /*
    eSetAttr/eGetAttr - An attempt to tame IE's weird DOM model
    - 22.11.2007 @ 12:50 - Initial version
    */
    function eSetAttr(objTarget,strAttr,strValue) {
    if (typeof window.attachEvent!='undefined' && typeof window.opera=='undefined') {
    //    //Set attributes for IE
	switch (strAttr) {
	    case('class'):
		objTarget.setAttribute('className',strValue);
		break;
	    case('style'):
		objTarget.style.cssText=strValue;
		break;
	    default:
		objTarget.setAttribute(strAttr,strValue);
		break;
	    }
	}
    else {
    //    //Set attributes for /Other browsers/
	objTarget.setAttribute(strAttr,strValue);
	}
    //66885349@N03
    }
    </script>
    <script type="text/javascript" src="https://api.flickr.com/services/feeds/photos_public.gne?id=66885349@N03&amp;format=json&amp;" defer="defer"></script>
</body>
</html>